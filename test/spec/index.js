// Generated by CoffeeScript 1.8.0
(function() {
  var AbButtonFixture, BootstrapButtonFixture, JsonFixture;

  describe('Unit. Interface IButtonState', (function(_this) {
    return function() {
      it('Интерфейс существует', function() {
        var expression;
        expression = typeof IButtonState === "function";
        return expect(expression).toBeTruthy();
      });
      return it('При создании экземпляра должно возникать исключение', function() {
        return expect(IButtonState).toThrow();
      });
    };
  })(this));

  describe('Unit. Interface IButton', (function(_this) {
    return function() {
      it('Интерфейс существует', function() {
        var expression;
        expression = typeof IButton === "function";
        return expect(expression).toBeTruthy();
      });
      return it('При создании экземпляра должно возникать исключение', function() {
        return expect(IButton).toThrow();
      });
    };
  })(this));

  describe('Unit. Interface IListener', (function(_this) {
    return function() {
      it('Интерфейс существует', function() {
        var expression;
        expression = typeof IListener === "function";
        return expect(expression).toBeTruthy();
      });
      return it('При создании экземпляра должно возникать исключение', function() {
        return expect(IListener).toThrow();
      });
    };
  })(this));

  describe('Unit. Abstract AbButtonStateBlocked', (function(_this) {
    return function() {
      it('Класс существует', function() {
        var expression;
        expression = typeof AbButtonStateBlocked === "function";
        return expect(expression).toBeTruthy();
      });
      describe('Unit. Abstract AbButtonStateBlocked. Method constructor()', function() {
        return it('Метод должен быть переопределен', function() {
          return expect(function() {
            return AbButtonFixture('AbButtonStateBlocked', JsonFixture.prototype.Get());
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButtonStateBlocked. Method actionClick()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateBlocked', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionClick(button);
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButtonStateBlocked. Method actionMouseOver()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateBlocked', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionMouseOver(button);
          }).not.toThrow();
        });
      });
      return describe('Unit. Abstract AbButtonStateBlocked. Method actionMouseOut()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateBlocked', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionMouseOut(button);
          }).not.toThrow();
        });
      });
    };
  })(this));

  describe('Unit. Abstract AbButtonStateCalm', (function(_this) {
    return function() {
      it('Класс существует', function() {
        var expression;
        expression = typeof AbButtonStateCalm === "function";
        return expect(expression).toBeTruthy();
      });
      describe('Unit. Abstract AbButtonStateCalm. Method constructor()', function() {
        return it('Метод должен быть переопределен', function() {
          return expect(function() {
            return AbButtonFixture('AbButtonStateCalm', JsonFixture.prototype.Get());
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButtonStateCalm. Method actionClick()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateCalm', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionClick(button);
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButtonStateCalm. Method actionMouseOver()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateCalm', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionMouseOver(button);
          }).not.toThrow();
        });
      });
      return describe('Unit. Abstract AbButtonStateCalm. Method actionMouseOut()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateCalm', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionMouseOut(button);
          }).not.toThrow();
        });
      });
    };
  })(this));

  describe('Unit. Abstract AbButtonStateFire', (function(_this) {
    return function() {
      it('Класс существует', function() {
        var expression;
        expression = typeof AbButtonStateFire === "function";
        return expect(expression).toBeTruthy();
      });
      describe('Unit. Abstract AbButtonStateFire. Method constructor()', function() {
        return it('Метод должен быть переопределен', function() {
          return expect(function() {
            return AbButtonFixture('AbButtonStateFire', JsonFixture.prototype.Get());
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButtonStateFire. Method actionClick()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateFire', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionClick(button);
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButtonStateFire. Method actionMouseOver()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateFire', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionMouseOver(button);
          }).not.toThrow();
        });
      });
      return describe('Unit. Abstract AbButtonStateFire. Method actionMouseOut()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateFire', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionMouseOut(button);
          }).not.toThrow();
        });
      });
    };
  })(this));

  describe('Unit. Abstract AbButtonStateWaiting', (function(_this) {
    return function() {
      it('Класс существует', function() {
        var expression;
        expression = typeof AbButtonStateWaiting === "function";
        return expect(expression).toBeTruthy();
      });
      describe('Unit. Abstract AbButtonStateWaiting. Method constructor()', function() {
        return it('Метод должен быть переопределен', function() {
          return expect(function() {
            return AbButtonFixture('AbButtonStateWaiting', JsonFixture.prototype.Get());
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButtonStateWaiting. Method actionClick()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateWaiting', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionClick(button);
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButtonStateWaiting. Method actionMouseOver()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateWaiting', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionMouseOver(button);
          }).not.toThrow();
        });
      });
      return describe('Unit. Abstract AbButtonStateWaiting. Method actionMouseOut()', function() {
        return it('Метод должен быть переопределен', function() {
          var button, state;
          button = AbButtonFixture('AbButtonStateWaiting', JsonFixture.prototype.Get());
          state = button.getState();
          return expect(function() {
            return state.actionMouseOut(button);
          }).not.toThrow();
        });
      });
    };
  })(this));

  describe('Unit. Abstract AbButton', (function(_this) {
    return function() {
      it('Класс существует', function() {
        var expression;
        expression = typeof AbButton === "function";
        return expect(expression).toBeTruthy();
      });
      describe('Unit. Abstract AbButton. Method constructor()', function() {
        it('Метод должен быть переопределен', function() {
          return expect(function() {
            return AbButtonFixture(null, JsonFixture.prototype.Get());
          }).not.toThrow();
        });
        it('При отсуствиии json, должно быть исключение', function() {
          return expect(function() {
            return AbButtonFixture();
          }).toThrow();
        });
        it('Если параметр state передается, то он должен принадлежать интерфесу имя класса существующего состояния, иначе исключение', function() {
          return expect(function() {
            return AbButtonFixture('State');
          }).toThrow();
        });
        return it('Конструктор должен вернуть экземпляр IButton', function() {
          var button;
          button = new AbButton(null, JsonFixture.prototype.Get());
          return expect(button instanceof IButton).toBeTruthy();
        });
      });
      describe('Unit. Abstract AbButton. Method getState()', function() {
        it('Метод должен быть переопределен', function() {
          var button;
          button = new AbButton(null, JsonFixture.prototype.Get());
          return expect(button.getState).not.toThrow();
        });
        it('Метод должен возвращать тип IButtonState', function() {
          var button, state;
          button = new AbButton(null, JsonFixture.prototype.Get());
          state = button.getState();
          return expect(state instanceof IButtonState).toBeTruthy();
        });
        return it('Метод должен возвращать тип который устанвливается в конструкторе для state, при передаче явно', function() {
          var button, stateEnd;
          button = new AbButton('AbButtonStateCalm', JsonFixture.prototype.Get());
          stateEnd = button.getState();
          return expect(stateEnd instanceof AbButtonStateCalm).toBeTruthy();
        });
      });
      describe('Unit. Abstract AbButton. Method setState()', function() {
        it('Метод должен быть переопределен', function() {
          var foo;
          foo = function() {
            var button;
            button = new AbButton(null, JsonFixture.prototype.Get());
            return button.setState(new AbButtonStateCalm(button));
          };
          return expect(foo).not.toThrow();
        });
        return it('Метод должен принимать только тип IButtonState, иначе исключение', function() {
          var foo;
          foo = function() {
            var button;
            button = new AbButton(null, JsonFixture.prototype.Get());
            return button.setState({});
          };
          return expect(foo).toThrow();
        });
      });
      describe('Unit. Abstract AbButton. Method getListener()', function() {
        it('Метод должен быть переопределен', function() {
          var foo;
          foo = function() {
            var button;
            button = new AbButton(null, JsonFixture.prototype.Get());
            return button.getListener();
          };
          return expect(foo).not.toThrow();
        });
        return it('Метод должен возвращать тип IListener', function() {
          var button, listener;
          button = new AbButton(null, JsonFixture.prototype.Get());
          listener = button.getListener();
          return expect(listener instanceof IListener).toBeTruthy();
        });
      });
      describe('Unit. Abstract AbButton. Method getActionClick()', function() {
        return it('Метод должен быть переопределен', function() {
          return expect(function() {
            return AbButtonFixture(null, JsonFixture.prototype.Get(), 'actionClick');
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButton. Method getActionMouseOver()', function() {
        return it('Метод должен быть переопределен', function() {
          return expect(function() {
            return AbButtonFixture(null, JsonFixture.prototype.Get(), 'actionMouseOver');
          }).not.toThrow();
        });
      });
      describe('Unit. Abstract AbButton. Method getActionMouseOut()', function() {
        return it('Метод должен быть переопределен', function() {
          return expect(function() {
            return AbButtonFixture(null, JsonFixture.prototype.Get(), 'actionMouseOut');
          }).not.toThrow();
        });
      });
      return describe('Unit. Получение состояний(для полиморфизма)', function() {
        var button;
        button = null;
        beforeEach(function() {
          return button = AbButtonFixture(null, JsonFixture.prototype.Get());
        });
        afterEach(function() {
          return button = null;
        });
        describe('Unit. Abstract AbButton. Method getStateCalm()', function() {
          it('Метод должен существовать', function() {
            return expect(function() {
              return button.getStateCalm();
            }).not.toThrow();
          });
          return it('Метод должен возвращать экземпляр типа IButtonState', function() {
            return expect(button.getStateCalm() instanceof IButtonState).toBeTruthy();
          });
        });
        describe('Unit. Abstract AbButton. Method getStateFire()', function() {
          it('Метод должен существовать', function() {
            return expect(function() {
              return button.getStateFire();
            }).not.toThrow();
          });
          return it('Метод должен возвращать экземпляр типа IButtonState', function() {
            return expect(button.getStateFire() instanceof IButtonState).toBeTruthy();
          });
        });
        describe('Unit. Abstract AbButton. Method getStateWaiting()', function() {
          it('Метод должен существовать', function() {
            return expect(function() {
              return button.getStateWaiting();
            }).not.toThrow();
          });
          return it('Метод должен возвращать экземпляр типа IButtonState', function() {
            return expect(button.getStateWaiting() instanceof IButtonState).toBeTruthy();
          });
        });
        return describe('Unit. Abstract AbButton. Method getStateBlocked()', function() {
          it('Метод должен существовать', function() {
            return expect(function() {
              return button.getStateBlocked();
            }).not.toThrow();
          });
          return it('Метод должен возвращать экземпляр типа IButtonState', function() {
            return expect(button.getStateBlocked() instanceof IButtonState).toBeTruthy();
          });
        });
      });
    };
  })(this));

  describe('Unit. Abstract AbListener', (function(_this) {
    return function() {
      it('Класс существует', function() {
        var expression;
        expression = typeof AbListener === "function";
        return expect(expression).toBeTruthy();
      });
      describe('Unit. Abstract AbListener. Method constructor()', function() {
        it('Метод должен быть переопределен', function() {
          return expect(function() {
            return new AbListener(JsonFixture.prototype.Get());
          }).not.toThrow();
        });
        it('Метод не дожен принимать нулевое значение', function() {
          return expect(function() {
            return new AbListener(null);
          }).toThrow();
        });
        it('Метод должен содержать поле title', function() {
          return expect(function() {
            return new AbListener(JsonFixture.prototype.GetWithoOtTitle());
          }).toThrow();
        });
        it('Метод должен содержать поле defaultState', function() {
          return expect(function() {
            return new AbListener(JsonFixture.prototype.GetWithOtDefaultState());
          }).toThrow();
        });
        it('Метод должен содержать поле owner', function() {
          return expect(function() {
            return new AbListener(JsonFixture.prototype.GetWithOtOwner());
          }).toThrow();
        });
        it('DOM должен содержать owner', function() {
          var json, owner;
          json = JsonFixture.prototype.Get();
          owner = json.owner;
          return expect($(owner)).toExist();
        });
        return it('Метод должен провоцировать исключение, если в доме нет owner', function() {
          return expect(function() {
            return new AbListener(JsonFixture.prototype.GetIncorrectOwner());
          }).toThrow();
        });
      });
      describe('Unit. Abstract AbListener. Method getTitle()', function() {
        it('Метод должен быть переопределен', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(function() {
            return listener.getTitle();
          }).not.toThrow();
        });
        return it('Метод должен возврщать значение', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(listener.getTitle()).not.toBeNull();
        });
      });
      describe('Unit. Abstract AbListener. Method setTitle()', function() {
        it('Метод должен быть переопределен', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(function() {
            return listener.setTitle('my title');
          }).not.toThrow();
        });
        it('Метод должен устанавливать значение', function() {
          var listener, title1, title2;
          listener = new AbListener(JsonFixture.prototype.Get());
          title1 = listener.getTitle();
          listener.setTitle('My Title');
          title2 = listener.getTitle();
          return expect(title1).not.toEqual(title2);
        });
        it('Устанавливаемое значение не должно быть пустым', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(function() {
            return listener.setTitle(null);
          }).toThrow();
        });
        it('Устанавливаемое значение должно быть длинее 0', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(function() {
            return listener.setTitle('');
          }).toThrow();
        });
        return it('Устанавливаемое значение должно быть строкой', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(function() {
            return listener.setTitle({
              'object': 'object'
            });
          }).toThrow();
        });
      });
      describe('Unit. Abstract AbListener. Method getAction()', function() {
        it('Метод должен быть переопределен', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(function() {
            return listener.getTitle('actionClick');
          }).not.toThrow();
        });
        it('Метод должен возвращать function', function() {
          var action, listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          action = listener.getAction('actionClick');
          return expect(typeof action === 'function').toBeTruthy();
        });
        return it('Метод должен бросать исключение, если запрашивается неизвестная функция', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(function() {
            return json.listener[actionName];
          }).toThrow();
        });
      });
      describe('Unit. Abstract AbListener. Method getOwner()', function() {
        it('Метод должен быть переопределен', function() {
          var listener;
          listener = new AbListener(JsonFixture.prototype.Get());
          return expect(function() {
            return listener.getOwner();
          }).not.toThrow();
        });
        return it('Метод должен возвращать не пустое значение', function() {
          var listener, owner;
          listener = new AbListener(JsonFixture.prototype.Get());
          owner = listener.getOwner();
          return expect(owner).not.toBeNull();
        });
      });
      return describe('Тестируем кнопу на стандартном наборе входных значений c titles. JsonFixture::GetWithTitles()', function() {
        var listener;
        listener = null;
        beforeEach(function() {
          return listener = new AbListener(JsonFixture.prototype.GetWithTitles());
        });
        afterEach(function() {
          return listener = null;
        });
        it('Метод getTitle(state) должен возвращать title при state == "calm"', function() {
          return expect(listener.getTitle('calm')).not.toBeNull();
        });
        it('Метод getTitle(state) должен возвращать title при state == null', function() {
          return expect(listener.getTitle()).not.toBeNull();
        });
        return it('Метод getTitle(state) должен бросать исключение, при state == ???', function() {
          return expect(function() {
            return listener.getTitle('calming');
          }).toThrow();
        });
      });
    };
  })(this));

  AbButtonFixture = function(stateName, json, action) {
    var button;
    if (action == null) {
      action = null;
    }
    button = new AbButton(stateName, json);
    if (action == null) {
      return button;
    }
    if (typeof AbButton[action] === 'function') {
      return button[action]();
    }
  };

  BootstrapButtonFixture = (function() {
    function BootstrapButtonFixture() {}

    BootstrapButtonFixture.prototype.ASYNC_TIMER = 100;

    BootstrapButtonFixture.prototype.ASYNC_TIMER_STEP = 20;

    BootstrapButtonFixture.prototype.Get = function() {
      return {
        "title": 'Bootstrap Button',
        "owner": "#bootstrap-button",
        "defaultState": "BootstrapButtonStateCalm",
        "listener": {
          "actionClick": (function(_this) {
            return function(B) {
              return setTimeout((function() {
                return B.setState(B.getStateBlocked());
              }), _this.ASYNC_TIMER);
            };
          })(this),
          "actionMouseOver": (function(_this) {
            return function(B) {};
          })(this),
          "actionMouseOut": (function(_this) {
            return function(B) {};
          })(this)
        }
      };
    };

    BootstrapButtonFixture.prototype.GetWithTitles = function() {
      return {
        "title": 'Abstract Button',
        "titles": {
          "calm": "Bootstrap Button - calm",
          "fire": "Bootstrap Button - fire",
          "waiting": "Bootstrap Button - waiting",
          "blocked": "Bootstrap Button - blocked"
        },
        "owner": "#btn1",
        "defaultState": "BootstrapButtonStateCalm",
        "listener": {
          "actionClick": (function(_this) {
            return function(B) {
              return setTimeout((function() {
                return B.setState(B.getStateBlocked());
              }), _this.ASYNC_TIMER);
            };
          })(this),
          "actionMouseOver": (function(_this) {
            return function(B) {};
          })(this),
          "actionMouseOut": (function(_this) {
            return function(B) {};
          })(this)
        }
      };
    };

    return BootstrapButtonFixture;

  })();

  JsonFixture = (function() {
    function JsonFixture() {}

    JsonFixture.prototype.ASYNC_TIMER = 100;

    JsonFixture.prototype.ASYNC_TIMER_STEP = 20;

    JsonFixture.prototype.Get = function() {
      return {
        "title": 'Abstract Button',
        "owner": "#btn",
        "defaultState": "AbButtonStateCalm",
        "listener": {
          "actionClick": (function(_this) {
            return function(B) {
              return setTimeout((function() {
                return B.setState(B.getStateBlocked());
              }), _this.ASYNC_TIMER);
            };
          })(this),
          "actionMouseOver": (function(_this) {
            return function(B) {};
          })(this),
          "actionMouseOut": (function(_this) {
            return function(B) {};
          })(this)
        }
      };
    };

    JsonFixture.prototype.GetWithTitles = function() {
      return {
        "title": 'Abstract Button',
        "titles": {
          "calm": "Abstract Button - calm",
          "fire": "Abstract Button - fire",
          "waiting": "Abstract Button - waiting",
          "blocked": "Abstract Button - blocked"
        },
        "owner": "#btn",
        "defaultState": "AbButtonStateCalm",
        "listener": {
          "actionClick": (function(_this) {
            return function(B) {
              return setTimeout((function() {
                return B.setState(B.getStateBlocked());
              }), _this.ASYNC_TIMER);
            };
          })(this),
          "actionMouseOver": (function(_this) {
            return function(B) {};
          })(this),
          "actionMouseOut": (function(_this) {
            return function(B) {};
          })(this)
        }
      };
    };

    JsonFixture.prototype.GetWithOtOwner = function() {
      return {
        "title": 'Abstract Button',
        "defaultState": "AbButtonStateCalm",
        "listener": {
          "actionClick": (function(_this) {
            return function(e) {
              return console.log('onClick');
            };
          })(this),
          "actionMouseOver": (function(_this) {
            return function(e) {
              return console.log('onMouseOver');
            };
          })(this),
          "actionMouseOut": (function(_this) {
            return function(e) {
              return console.log('onMouseOut');
            };
          })(this)
        }
      };
    };

    JsonFixture.prototype.GetIncorrectOwner = function() {
      return {
        "title": 'Abstract Button',
        "owner": "#btncdscdscdsvdsvdsvdfsv",
        "defaultState": "AbButtonStateCalm",
        "listener": {
          "actionClick": (function(_this) {
            return function(e) {
              return console.log('onClick');
            };
          })(this),
          "actionMouseOver": (function(_this) {
            return function(e) {
              return console.log('onMouseOver');
            };
          })(this),
          "actionMouseOut": (function(_this) {
            return function(e) {
              return console.log('onMouseOut');
            };
          })(this)
        }
      };
    };

    JsonFixture.prototype.GetWithOtDefaultState = function() {
      return {
        "title": 'Abstract Button',
        "owner": "#btn",
        "listener": {
          "actionClick": (function(_this) {
            return function(e) {
              return console.log('onClick');
            };
          })(this),
          "actionMouseOver": (function(_this) {
            return function(e) {
              return console.log('onMouseOver');
            };
          })(this),
          "actionMouseOut": (function(_this) {
            return function(e) {
              return console.log('onMouseOut');
            };
          })(this)
        }
      };
    };

    JsonFixture.prototype.GetWithOutTitle = function() {
      return {
        "owner": "#btn",
        "defaultState": "AbButtonStateCalm",
        "listener": {
          "actionClick": (function(_this) {
            return function(e) {
              return console.log('onClick');
            };
          })(this),
          "actionMouseOver": (function(_this) {
            return function(e) {
              return console.log('onMouseOver');
            };
          })(this),
          "actionMouseOut": (function(_this) {
            return function(e) {
              return console.log('onMouseOut');
            };
          })(this)
        }
      };
    };

    return JsonFixture;

  })();

  describe('Behavior. AbButton Family', (function(_this) {
    return function() {
      describe('Тестируем кнопу на стандартном наборе входных значений', function() {
        var $owner, button, listener, owner;
        button = null;
        listener = null;
        owner = null;
        $owner = null;
        beforeEach(function() {
          button = new AbButton(null, JsonFixture.prototype.Get());
          listener = button.getListener();
          owner = listener.getOwner();
          return $owner = listener.$owner;
        });
        afterEach(function() {
          button = null;
          listener = null;
          owner = null;
          return $owner = null;
        });
        it('Кнопка существует', function() {
          return expect(owner).toBeInDOM();
        });
        it('Кнопка по умолчанию не должна иметь атрибут :disabled', function() {
          return expect(owner).not.toBeDisabled();
        });
        it('Изначально кнопка должна иметь атрибут state', function() {
          return expect(owner).toHaveAttr('state');
        });
        it('Изначально кнопка должна иметь state == calm, если не задан нужный класс состояния', function() {
          return expect($owner.attr('state')).toEqual('calm');
        });
        it('При mouseover кнопка должна изменить состояние на AbButtonStateFire', function() {
          $owner.trigger('mouseover');
          return expect(button.getState() instanceof AbButtonStateFire).toEqual(true);
        });
        it('При mouseover -> mouseout кнопка должна изменить состояние на AbButtonStateCalm', function() {
          $owner.trigger('mouseover');
          $owner.trigger('mouseout');
          return expect(button.getState() instanceof AbButtonStateCalm).toEqual(true);
        });
        it('При mouseover -> click кнопка должна изменить состояние на AbButtonStateWaiting', function() {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return expect(button.getState() instanceof AbButtonStateWaiting).toEqual(true);
        });
        it('При mouseover -> click -> click -> click кнопка должна иметь состояние AbButtonStateWaiting', function() {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return expect(button.getState() instanceof AbButtonStateWaiting).toEqual(true);
        });
        it('При mouseover -> click -> time кнопка должна изменить состояние на AbButtonStateBlocked', function(done) {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return setTimeout((function() {
            expect(button.getState() instanceof AbButtonStateBlocked).toEqual(true);
            return done();
          }), JsonFixture.prototype.ASYNC_TIMER + JsonFixture.prototype.ASYNC_TIMER_STEP);
        });
        it('При mouseover -> click -> time -> click не кнопка должна изменять состояние', function(done) {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return setTimeout((function() {
            $owner.trigger('click');
            expect(button.getState() instanceof AbButtonStateBlocked).toEqual(true);
            return done();
          }), JsonFixture.prototype.ASYNC_TIMER + JsonFixture.prototype.ASYNC_TIMER_STEP);
        });
        it('В состоянии AbButtonStateBlocked кнопка не должна менять свое состояние, ни при какиз воздействиях', function(done) {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return setTimeout((function() {
            $owner.trigger('mouseover');
            expect(button.getState() instanceof AbButtonStateBlocked).toEqual(true);
            $owner.trigger('mouseout');
            expect(button.getState() instanceof AbButtonStateBlocked).toEqual(true);
            return done();
          }), JsonFixture.prototype.ASYNC_TIMER + JsonFixture.prototype.ASYNC_TIMER_STEP);
        });
        return describe('При смене состояний кнопка должна иметь title, который в нее заложен, если не указаны titles для состояний', function() {
          it('При состоянии calm', function() {
            var title;
            title = listener.getTitle();
            return expect($owner.text()).toContain(title);
          });
          it('При состоянии fire', function() {
            var title;
            $owner.trigger('mouseover');
            title = listener.getTitle();
            return expect($owner.text()).toContain(title);
          });
          it('При состоянии fire -> calm', function() {
            var title;
            $owner.trigger('mouseover');
            $owner.trigger('mouseout');
            title = listener.getTitle();
            return expect($owner.text()).toContain(title);
          });
          it('При состоянии waiting', function() {
            var title;
            $owner.trigger('mouseover');
            $owner.trigger('click');
            title = listener.getTitle();
            return expect($owner.text()).toContain(title);
          });
          return it('В состоянии blocked', function(done) {
            $owner.trigger('mouseover');
            $owner.trigger('click');
            return setTimeout((function() {
              var title;
              title = listener.getTitle();
              expect($owner.text()).toContain(title);
              return done();
            }), JsonFixture.prototype.ASYNC_TIMER + JsonFixture.prototype.ASYNC_TIMER_STEP);
          });
        });
      });
      return describe('Тестируем кнопу на стандартном наборе входных значений c titles по состояниям JsonFixture::GetWithTitles()', function() {
        var $owner, button, listener, owner;
        button = null;
        listener = null;
        owner = null;
        $owner = null;
        beforeEach(function() {
          button = new AbButton(null, JsonFixture.prototype.GetWithTitles());
          listener = button.getListener();
          owner = listener.getOwner();
          return $owner = listener.$owner;
        });
        afterEach(function() {
          button = null;
          listener = null;
          owner = null;
          return $owner = null;
        });
        return describe('При смене состояний кнопка должна иметь соотвествующий title ее состоянию', function() {
          it('При состоянии calm', function() {
            return expect($owner.text()).toMatch("calm");
          });
          it('При состоянии fire', function() {
            $owner.trigger('mouseover');
            return expect($owner.text()).toMatch("fire");
          });
          it('При состоянии fire -> calm', function() {
            $owner.trigger('mouseover');
            $owner.trigger('mouseout');
            return expect($owner.text()).toMatch("calm");
          });
          it('При состоянии waiting', function() {
            $owner.trigger('mouseover');
            $owner.trigger('click');
            return expect($owner.text()).toMatch("waiting");
          });
          return it('В состоянии blocked', function(done) {
            $owner.trigger('mouseover');
            $owner.trigger('click');
            return setTimeout((function() {
              expect($owner.text()).toMatch("blocked");
              return done();
            }), JsonFixture.prototype.ASYNC_TIMER + JsonFixture.prototype.ASYNC_TIMER_STEP);
          });
        });
      });
    };
  })(this));

  describe('Behavior. BootstrapButton Family', (function(_this) {
    return function() {
      return describe('Тестируем кнопу на стандартном наборе входных значений', function() {
        var $owner, button, listener, owner;
        button = null;
        listener = null;
        owner = null;
        $owner = null;
        beforeEach(function() {
          button = new BootstrapButton(null, BootstrapButtonFixture.prototype.Get());
          listener = button.getListener();
          owner = listener.getOwner();
          return $owner = listener.$owner;
        });
        afterEach(function() {
          button = null;
          listener = null;
          owner = null;
          return $owner = null;
        });
        it('Кнопка существует', function() {
          return expect(owner).toBeInDOM();
        });
        it('Кнопка по умолчанию не должна иметь атрибут :disabled', function() {
          return expect(owner).not.toBeDisabled();
        });
        it('Изначально кнопка должна иметь атрибут state', function() {
          return expect(owner).toHaveAttr('state');
        });
        it('Изначально кнопка должна иметь state == calm, если не задан нужный класс состояния', function() {
          return expect($owner.attr('state')).toEqual('calm');
        });
        it('При mouseover кнопка должна изменить состояние на BootstrapButtonStateFire', function() {
          $owner.trigger('mouseover');
          return expect(button.getState() instanceof BootstrapButtonStateFire).toEqual(true);
        });
        it('При mouseover -> mouseout кнопка должна изменить состояние на BootstrapButtonStateCalm', function() {
          $owner.trigger('mouseover');
          $owner.trigger('mouseout');
          return expect(button.getState() instanceof BootstrapButtonStateCalm).toEqual(true);
        });
        it('При mouseover -> click кнопка должна изменить состояние на BootstrapButtonStateWaiting', function() {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return expect(button.getState() instanceof BootstrapButtonStateWaiting).toEqual(true);
        });
        it('При mouseover -> click -> click -> click кнопка должна иметь состояние BootstrapButtonStateWaiting', function() {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return expect(button.getState() instanceof BootstrapButtonStateWaiting).toEqual(true);
        });
        it('При mouseover -> click -> time кнопка должна изменить состояние на BootstrapButtonStateBlocked', function(done) {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return setTimeout((function() {
            expect(button.getState() instanceof BootstrapButtonStateBlocked).toEqual(true);
            return done();
          }), BootstrapButtonFixture.prototype.ASYNC_TIMER + BootstrapButtonFixture.prototype.ASYNC_TIMER_STEP);
        });
        it('При mouseover -> click -> time -> click не кнопка должна изменять состояние', function(done) {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return setTimeout((function() {
            $owner.trigger('click');
            expect(button.getState() instanceof BootstrapButtonStateBlocked).toEqual(true);
            return done();
          }), BootstrapButtonFixture.prototype.ASYNC_TIMER + BootstrapButtonFixture.prototype.ASYNC_TIMER_STEP);
        });
        return it('В состоянии BootstrapButtonStateBlocked кнопка не должна менять свое состояние, ни при какиз воздействиях', function(done) {
          $owner.trigger('mouseover');
          $owner.trigger('click');
          return setTimeout((function() {
            $owner.trigger('mouseover');
            expect(button.getState() instanceof BootstrapButtonStateBlocked).toEqual(true);
            $owner.trigger('mouseout');
            expect(button.getState() instanceof BootstrapButtonStateBlocked).toEqual(true);
            return done();
          }), BootstrapButtonFixture.prototype.ASYNC_TIMER + BootstrapButtonFixture.prototype.ASYNC_TIMER_STEP);
        });
      });
    };
  })(this));

}).call(this);
